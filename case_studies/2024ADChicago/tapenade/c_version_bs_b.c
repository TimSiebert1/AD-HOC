/*        Generated by TAPENADE     (INRIA, Ecuador team)
    Tapenade 3.16 (develop) - 25 Oct 2024 09:00
*/
#include "adStack.h"
#include <math.h>
#include <stdio.h>

/*
  Differentiation of cdf_n in reverse (adjoint) mode:
   gradient     of useful results: cdf_n
   with respect to varying inputs: x
*/
void cdf_n_b(double x, double *xb, double cdf_nb) {
    *xb = 0.70710678118654746*1.1283791671*exp(-(-(0.70710678118654746*x)*-(
        0.70710678118654746*x)))*0.5*cdf_nb;
}

double cdf_n_nodiff(double x) {
    return 0.5*erfc(x*-0.70710678118654746);
}

/*
  Differentiation of call_price in reverse (adjoint) mode:
   gradient     of useful results: v call_price K S T
   with respect to varying inputs: v K S T
   RW status of diff variables: v:incr call_price:in-killed K:incr
                S:incr T:incr
*/
void call_price_b(double S, double *Sb, double K, double *Kb, double v, double
        *vb, double T, double *Tb, double call_priceb) {
    double totalvol = v*sqrt(T);
    double totalvolb = 0.0;
    double d1 = log(S/K)/totalvol + totalvol*0.5;
    double d1b = 0.0;
    double d2 = d1 - totalvol;
    double d2b = 0.0;
    double result1;
    double result1b;
    double result2;
    double result2b;
    double temp;
    double tempb;
    result1 = cdf_n_nodiff(d1);
    result2 = cdf_n_nodiff(d2);
    result1b = S*call_priceb;
    result2b = -(K*call_priceb);
    d2b = 0.0;
    cdf_n_b(d2, &d2b, result2b);
    d1b = 0.0;
    cdf_n_b(d1, &d1b, result1b);
    d1b = d1b + d2b;
    temp = S/K;
    tempb = d1b/(K*temp*totalvol);
    *Sb = *Sb + result1*call_priceb + tempb;
    *Kb = *Kb - result2*call_priceb - temp*tempb;
    totalvolb = (0.5-log(temp)/(totalvol*totalvol))*d1b - d2b;
    temp = sqrt(T);
    *vb = *vb + temp*totalvolb;
    if (!(T==0.0))
        *Tb = *Tb + v*totalvolb/(2.0*temp);
}
